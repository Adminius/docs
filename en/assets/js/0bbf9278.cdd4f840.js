"use strict";(self.webpackChunkevcc_docs=self.webpackChunkevcc_docs||[]).push([[8266],{1530:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>a});var r=i(5893),t=i(1151);const o={sidebar_position:4},s="Modbus",c={id:"reference/modbus",title:"Modbus",description:"Some devices, such as meters (meters) or chargers (chargers), are connected and addressed using the Modbus protocol.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/reference/modbus.md",sourceDirName:"reference",slug:"/reference/modbus",permalink:"/en/docs/reference/modbus",draft:!1,unlisted:!1,editUrl:"https://github.com/evcc-io/docs/tree/main/i18n/en/docusaurus-plugin-content-docs/current/reference/modbus.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Plugins",permalink:"/en/docs/reference/plugins"},next:{title:"API",permalink:"/en/docs/reference/api"}},d={},a=[{value:"Physical Connection",id:"physical-connection",level:2},{value:"Serial Connection (RS485)",id:"serial-connection-rs485",level:3},{value:"Direct Network Connection",id:"direct-network-connection",level:3},{value:"Serial Device via Network Connection (with Interface Converter)",id:"serial-device-via-network-connection-with-interface-converter",level:3},{value:"Predefined Devices",id:"predefined-devices",level:2},{value:"Manual Configuration",id:"manual-configuration",level:2},{value:"Writing Registers",id:"writing-registers",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"modbus",children:"Modbus"}),"\n",(0,r.jsxs)(n.p,{children:["Some devices, such as meters (",(0,r.jsx)(n.a,{href:"/docs/reference/configuration/meters#modbus",children:(0,r.jsx)(n.code,{children:"meters"})}),") or chargers (",(0,r.jsx)(n.a,{href:"/docs/reference/configuration/chargers",children:(0,r.jsx)(n.code,{children:"chargers"})}),"), are connected and addressed using the Modbus protocol."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"meter"})," configuration includes the type of physical connection (interface), optional technical interface parameters, the Modbus protocol used, the unique Modbus ID of the device on the bus, and the number and type of the register to be read or written."]}),"\n",(0,r.jsx)(n.p,{children:"It is important to note that there are three different Modbus protocols: Modbus RTU, Modbus ASCII, and Modbus TCP. These can technically be transmitted over different types of interfaces. The classic version is Modbus RTU over a serial RS485 bus interface, commonly used with most meters or some chargers. Devices with a native network interface (Ethernet/WiFi), on the other hand, are typically addressed using the Modbus TCP protocol."}),"\n",(0,r.jsx)(n.p,{children:'If a serial Modbus device needs to be connected through an interface converter via a network (Ethernet/WiFi/PowerLAN), Modbus RTU protocol over a TCP/IP connection is established. The Modbus RTU protocol is directly transmitted over the network (i.e., "tunnelled"). Even though the transport method (TCP/IP) is the same, the protocol is NOT the same as Modbus TCP. It\'s essential to distinguish between the protocol and the transport method. "Modbus (RTU) over TCP" is different from Modbus TCP!'}),"\n",(0,r.jsx)(n.admonition,{type:"caution",children:(0,r.jsx)(n.p,{children:"Caution: There are more complex interface converters that can optionally translate the Modbus protocol itself between Modbus RTU and Modbus TCP!\nIf this feature is active, evcc must communicate with the converter using Modbus TCP, while the converter communicates with the serial device via Modbus RTU and bidirectionally translates the two protocols.\nIn this case, careful attention must be paid to the device specification and configuration; otherwise, communication might not work!"})}),"\n",(0,r.jsx)(n.p,{children:"In the case of a configuration with an interface converter, the serial bus configuration is determined only on the converter. The evcc configuration then concerns only the section up to the converter."}),"\n",(0,r.jsx)(n.h2,{id:"physical-connection",children:"Physical Connection"}),"\n",(0,r.jsx)(n.h3,{id:"serial-connection-rs485",children:"Serial Connection (RS485)"}),"\n",(0,r.jsxs)(n.p,{children:["If the device is directly connected via an RS485 adapter (Modbus RTU), ",(0,r.jsx)(n.code,{children:"device"})," and the serial communication parameters ",(0,r.jsx)(n.code,{children:"baudrate"})," and ",(0,r.jsx)(n.code,{children:"comset"})," must be specified according to the device configuration. Please refer to the respective user manual, data sheets, or system settings."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"Multiple devices with identical communication parameters can be operated on a serial RS485 bus if each device is assigned a unique Modbus ID. If not all devices on a bus can be configured with uniform communication settings (but with different IDs), splitting into multiple independent bus systems is necessary."})}),"\n",(0,r.jsx)(n.admonition,{type:"caution",children:(0,r.jsx)(n.p,{children:"Mixing devices with different serial communication parameters on a bus is not possible and leads to unpredictable communication errors."})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"For example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'source: modbus\nid: 1\ndevice: /dev/ttyUSB0\nbaudrate: 38400\ncomset: "8E1"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"direct-network-connection",children:"Direct Network Connection"}),"\n",(0,r.jsxs)(n.p,{children:["If the device is directly connected via a native network connection (Modbus TCP), a ",(0,r.jsx)(n.code,{children:"uri"})," consisting of HOSTNAME",":PORT"," or IP",":PORT"," must be provided:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"For example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"source: modbus\nid: 1\nuri: 192.168.0.11:502\n"})}),"\n",(0,r.jsx)(n.h3,{id:"serial-device-via-network-connection-with-interface-converter",children:"Serial Device via Network Connection (with Interface Converter)"}),"\n",(0,r.jsxs)(n.p,{children:["If a serial device is connected via an intermediate transparent RS485-IP interface converter (without protocol translation), the protocol must also be switched to Modbus RTU over the TCP/IP connection using ",(0,r.jsx)(n.code,{children:"rtu: true"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"For example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"source: modbus\nid: 1\nuri: 192.168.0.10:502\nrtu: true # Modbus RTU over TCP\n"})}),"\n",(0,r.jsx)(n.h2,{id:"predefined-devices",children:"Predefined Devices"}),"\n",(0,r.jsxs)(n.p,{children:["The integrated predefined device models ",(0,r.jsx)(n.code,{children:"model"})," are identical to ",(0,r.jsx)(n.a,{href:"https://github.com/volkszaehler/mbmd/blob/master/docs/mbmd_run.md#options",children:"MBMD"}),":"]}),"\n",(0,r.jsx)(n.p,{children:"ABB       ABB A/B-Series meters\nDDM       DDM18SD\nDZG       DZG Metering GmbH DVH4013 meters\nIEM3000   Schneider Electric iEM3000 series\nINEPRO    Inepro Metering Pro 380\nJANITZA   Janitza meters\nMPM       Bernecker Engineering MPM3PM meters\nORNO1P    ORNO WE-514 & WE-515\nORNO1P504 ORNO WE-504\nORNO3P    ORNO WE-516 & WE-517\nSBC       Saia Burgess Controls ALE3 meters\nSDM       Eastron SDM630/120/72DMv2\nSDM220    Eastron SDM220\nSDM230    Eastron SDM230\nSDM72     Eastron SDM72\nSEMTR     SolarEdge SE-MTR-3Y"}),"\n",(0,r.jsxs)(n.p,{children:["Any ",(0,r.jsx)(n.code,{children:"model"})," that deviates from these is"]}),"\n",(0,r.jsxs)(n.p,{children:["treated as a ",(0,r.jsx)(n.em,{children:"SunSpec"})," device type."]}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"value"})," to define the value to be read from the device. All supported values are predefined in ",(0,r.jsx)(n.a,{href:"https://github.com/volkszaehler/mbmd/blob/master/meters/measurements.go#L28",children:"MBMD"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["In the case of a ",(0,r.jsx)(n.em,{children:"SunSpec"}),"-compatible inverter or meter, the values to be read are specified in the format ",(0,r.jsx)(n.code,{children:"model:[block:]point"})," according to the ",(0,r.jsx)(n.em,{children:"SunSpec"})," definition. For example, querying the DC power on the second string of a three-phase PV inverter (corresponding to SunSpec Model 103) is done as follows: ",(0,r.jsx)(n.code,{children:"value: 103:2:W"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The device ",(0,r.jsx)(n.code,{children:"model"})," and the slave ID ",(0,r.jsx)(n.code,{children:"id"})," are always required:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"For example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"source: modbus\n---\nmodel: sdm\nvalue: Power\nscale: -1 # floating point factor applied to result, e.g. for kW to W conversion\n"})}),"\n",(0,r.jsx)(n.h2,{id:"manual-configuration",children:"Manual Configuration"}),"\n",(0,r.jsx)(n.p,{children:"If the Modbus device is not directly supported, or if values different from the predefined models need to be read or written, Modbus registers can also be manually configured:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"For example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"source: modbus\n---\nregister:\n  address: 40070\n  type: holding # holding or input\n  decode: int32 # int16|32|64, uint16|32|64, float32|64 and u|int32s + float32s\nscale: -1.0 # floating point factor applied to result, e.g. for kW to W conversion\ntimeout: 2s # timeout, without unit in ns\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For the ",(0,r.jsx)(n.code,{children:"int32s/uint32s"})," decodings, the byte order is swapped, which is useful for E3/DC devices."]}),"\n",(0,r.jsx)(n.h3,{id:"writing-registers",children:"Writing Registers"}),"\n",(0,r.jsxs)(n.p,{children:["Both holding registers and coils can be written. For this, either ",(0,r.jsx)(n.code,{children:"type: writeholding"})," for holding registers or ",(0,r.jsx)(n.code,{children:"type: writecoil"})," for coils must be specified.\n",(0,r.jsx)(n.code,{children:"type: writeholding"})," always writes a 16-bit register (int or bool16). Therefore, for ",(0,r.jsx)(n.code,{children:"decode"}),", ",(0,r.jsx)(n.code,{children:"uint16"})," must always be specified.\n",(0,r.jsx)(n.code,{children:"type: writecoil"})," writes a coil. Specifications for ",(0,r.jsx)(n.code,{children:"decode"})," are ignored."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"For example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"source: modbus\n---\nregister:\n  address: 40070\n  type: writeholding # writeholding or writecoil\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>c,a:()=>s});var r=i(7294);const t={},o=r.createContext(t);function s(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);